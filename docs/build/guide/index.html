<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · tJMagnonHolon</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">tJMagnonHolon</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced</a></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pwrzosek/tJMagnonHolon/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><p>The purpose of this <a href="#Guide">Guide</a> is to provide a simple introduction to <a href="../#tJMagnonHolon">tJMagnonHolon</a> features. It will allow you to start producing research relevant data right away.</p><ul><li><a href="#Guide">Guide</a></li><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Tutorial">Tutorial</a></li><ul><li><a href="#Running-the-code">Running the code</a></li><li><a href="#System-definition">System definition</a></li><li><a href="#Model-generation-and-factorization">Model generation and factorization</a></li><li><a href="#Operators">Operators</a></li><li><a href="#Correlation-functions">Correlation functions</a></li></ul></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>To start using <a href="../#tJMagnonHolon">tJMagnonHolon</a> you need a distribution of Julia. You can download recent stable version from its official website <a href="https://julialang.org">julialang.org</a>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Check out the <a href="https://docs.julialang.org/en/v1/manual/getting-started/">Manual</a> section of the Julia documentation if you&#39;re not familiar with Julia programming language.</p></div></div><p>Following packages are required for <a href="../#tJMagnonHolon">tJMagnonHolon</a> code to work.</p><pre><code class="language-none">OrderedCollections
LinearAlgebra
SparseArrays
KrylovKit
DelimitedFiles
Dates
JSON</code></pre><p>To download them, open terminal and move to the following directory.</p><pre><code class="language-none">.../tJMagnonHolon/src/</code></pre><p>In terminal type following command.</p><pre><code class="language-none">julia setup.jl</code></pre><p>Required packages will be automatically downloaded and added to Julia (you need an internet connection). This step has to be done only once.  You can also add packages by yourself (e.g. if you already have some of them installed and don&#39;t wish to upgrade). </p><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p>Let us start with the basics.</p><h3 id="Running-the-code"><a class="docs-heading-anchor" href="#Running-the-code">Running the code</a><a id="Running-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-code" title="Permalink"></a></h3><p>Open terminal and move to the following directory.</p><pre><code class="language-none">.../tJMagnonHolon/src/</code></pre><ul><li>in terminal type <code>julia</code> to start julia process, then in Julia REPL type <code>include(&quot;run.jl&quot;)</code>.</li><li>alternatively type <code>julia run.jl</code> (to run without graphical interface).</li></ul><p>This will execute <code>example_script.jl</code> from <code>.../tJMagnonHolon/src/scripts/</code> directory with all the <a href="../#tJMagnonHolon">tJMagnonHolon</a> modules included. You can add more scripts to <code>.../tJMagnonHolon/src/scripts/</code> (or to any location of your choice).  To execute one or more of those scripts include them in <code>run.jl</code> file.</p><pre><code class="language-Julia">include(&quot;./scripts/my_script.jl&quot;)</code></pre><hr/><p>Let us now learn about the features of the <a href="../#tJMagnonHolon">tJMagnonHolon</a>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Open <code>example_script.jl</code> on a side and compare how the discussed features are put together into a single script.</p></div></div><div class="admonition is-info"><header class="admonition-header">[optional] Basic structure</header><div class="admonition-body"><p>It is convenient to define output type for results we want to collect. Let us call it <code>Data</code>.</p><pre><code class="language-Julia">Data = OrderedDict{String, Union{Int64, Float64, Array{Float64}, Array{ComplexF64}}}</code></pre><p>You can write your script in the main scope of Julia but wrapping it in a function (or few functions) helps in organizing and reusing the code.</p><pre><code class="language-Julia">function script()::Data
    ...
end</code></pre><p>Above defined function <code>script()</code> is supposed to return output of type <code>Data</code>. You can also add some arguments to function <code>script()</code> or use different function name.</p></div></div><h3 id="System-definition"><a class="docs-heading-anchor" href="#System-definition">System definition</a><a id="System-definition-1"></a><a class="docs-heading-anchor-permalink" href="#System-definition" title="Permalink"></a></h3><p>To perform any calculations we need to first define parameters of our system. All the system parameters are handled by <a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a> structure from <code>tJmodel1D</code> module. Let us use <code>system</code> for a corresponding variable name. There are multiple ways to define <code>system</code> but probably most readable is to use  <a href="../documentation/#Main.tJmodel1D.System-Tuple{Main.tJmodel1D.System}"><code>System</code></a>  function and provide a set of keyword arguments as in example below.  The order in which keyword arguments are listed is not important.</p><pre><code class="language-julia">system = Main.tJmodel1D.System(
    t           = 1.0,      # hole hopping
    J           = 1.0,      # spin coupling
    λ           = 1.0,      # magnon interaction
    α           = 1.0,      # XXZ anisotropy scaling
    size        = 16,       # number of lattice sites
    electrons   = 16,       # number of electrons
    spinsUp     = 8,        # number of spins up
    momentum    = 0         # internal momentum subspace
)</code></pre><pre class="documenter-example-output">Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 8, 0)</pre><h5 id="Hamiltonian"><a class="docs-heading-anchor" href="#Hamiltonian">Hamiltonian</a><a id="Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian" title="Permalink"></a></h5><p>The first four parameters <span>$\textcolor{orange}{t}, \textcolor{orange}{J}, \textcolor{orange}{\lambda}, \textcolor{orange}{\alpha}$</span> are parameters of the Hamiltonian <span>$\hat{H}$</span> (in magnon-holon basis).</p><p class="math-container">\[\hat{H} = \hat{H}_t + \hat{H}_{xx} + \hat{H}_z\]</p><p class="math-container">\[\hat{H}_t = \textcolor{orange}{t}\sum_{\langle i,j \rangle} \hat{h}_i^\dag \hat{h}_j \left( \hat{a}_i + \hat{a}_j^\dag \right) + \textrm{H.c.}\]</p><p class="math-container">\[\hat{H}_{xx} = \frac{\textcolor{orange}{\alpha} \textcolor{orange}{J}}{2} \sum_{\langle i,j \rangle} \hat{h}_i \hat{h}_i^\dag \left( \hat{a}_i \hat{a}_j + \hat{a}_i^\dag \hat{a}_j^\dag \right) \hat{h}_j \hat{h}_j^\dag\]</p><p class="math-container">\[\hat{H}_{z} = \frac{\textcolor{orange}{J}}{2} \sum_{\langle i,j \rangle} \hat{h}_i \hat{h}_i^\dag \left(\hat{a}_i^\dag \hat{a}_i + \hat{a}_j^\dag \hat{a}_j - 2 \textcolor{orange}{\lambda} \hat{a}_i^\dag \hat{a}_i \hat{a}_j^\dag \hat{a}_j - 1 \right) \hat{h}_j \hat{h}_j^\dag\]</p><p>The last four parameters <span>$\mathrm{\textcolor{orange}{size}, \textcolor{orange}{electrons}, \textcolor{orange}{spinsUp}, \textcolor{orange}{momentum}}$</span> are conserved by the Hamiltonian and point to a single subspace of the model (orthogonal to other subspaces). See section <a href="../advanced/#Advanced">Advanced</a> for detailed discussion.</p><h4 id="Other-ways-to-define-System"><a class="docs-heading-anchor" href="#Other-ways-to-define-System">Other ways to define System</a><a id="Other-ways-to-define-System-1"></a><a class="docs-heading-anchor-permalink" href="#Other-ways-to-define-System" title="Permalink"></a></h4><p>Used in the above example values for system parameters are equal to the default values defined inside the <code>tJmodel1D</code> module.  To create a <code>system</code> with default values it is enough to call  <a href="../documentation/#Main.tJmodel1D.System-Tuple{Main.tJmodel1D.System}"><code>System</code></a>  function without arguments.</p><pre><code class="language-julia">system = Main.tJmodel1D.System()</code></pre><pre class="documenter-example-output">Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 8, 0)</pre><p>You can also provide any subset of keyword arguments. Not provided arguments will take default values.</p><pre><code class="language-julia">system = Main.tJmodel1D.System(spinsUp = 0)</code></pre><pre class="documenter-example-output">Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 0, 0)</pre><p>Additionally, if you wish to avoid to explicitly writing arguments names, you can use a constructor of <a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a> structure.  In this case the order of arguments matters, and it follows: <code>(t, J, λ, α, size, electrons, spinsUp, momentum)</code>. </p><pre><code class="language-julia">system = Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 8, 0)</code></pre><pre class="documenter-example-output">Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 8, 0)</pre><p><a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a> structure is immutable meaning that once you define it you cannot change values of its fields. But sometimes you may want to create a new instance of <a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a>  (let&#39;s call it <code>newSystem</code>) that has only one or few fields changed with respect to some previously defined <code>system</code>. In such case you can provide <code>system</code> as an argument to <a href="../documentation/#Main.tJmodel1D.System-Tuple{Main.tJmodel1D.System}"><code>System</code></a> function, see below.</p><pre><code class="language-julia">newSystem = Main.tJmodel1D.System(system, electrons = system.electrons - 1, spinsUp = system.spinsUp - 1)</code></pre><pre class="documenter-example-output">Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 15, 7, 0)</pre><p>Defined above <code>newSystem</code> has one electron less and one spin up less than <code>system</code> (e.g. one electron with spin up was removed). Values of other parameters are copied from <code>system</code>.</p><h3 id="Model-generation-and-factorization"><a class="docs-heading-anchor" href="#Model-generation-and-factorization">Model generation and factorization</a><a id="Model-generation-and-factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Model-generation-and-factorization" title="Permalink"></a></h3><p>Once <code>system</code> is known, you can call defined in <code>tJmodel1D</code> module function <a href="../documentation/#Main.tJmodel1D.run"><code>run</code></a> to generate Hamiltonian matrix for subspace described by <code>system</code> and factorize it.</p><pre><code class="language-Julia">system, basis, model, factorization = Main.tJmodel1D.run(system)</code></pre><p>This function returns 3 objects and a tuple:</p><ul><li><a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a> - parameters of the system subspace.</li><li><a href="../documentation/#Main.tJmodel1D.Basis"><code>Basis</code></a> - basis of representative magnon-holon states for the system subspace.</li><li><a href="../documentation/#Main.tJmodel1D.Model"><code>Model</code></a> - generated sparse matrix of the Hamiltonian for the system subspace.</li><li><code>factorization = (eigenvalues, eigenvectors, convergenceInfo)</code> - results of diagonalization procedure.</li></ul><div class="admonition is-info"><header class="admonition-header">Type and value note</header><div class="admonition-body"><ul><li>Note that <code>eltype(eigenvalues) &lt;: ComplexF64</code>. Complex numbers may be returned if <code>Model</code> matrix has complex coefficients (even if imaginary parts are numerically zero). It is safe to assume that:</li></ul><pre><code class="language-Julia">eigenvalues::Vector{ComplexF64}
eigenvectors::Vector{Vector{ComplexF64}}</code></pre><ul><li>Note that eigenvectors are determined up to a random (complex) phase that changes from run to run.</li></ul></div></div><p>You can easily access calculated eigenvalues and eigenvectors. For example, the first value and its corresponding vector:</p><pre><code class="language-Julia">eigenvalues, eigenvectors, info = factorization
ψ = eigenvectors[1]
E0 = real(eigenvalues[1])</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Eigenvalues are sorted with respect to real part from smallest to largest.</p></div></div><p>By default, only 1 eigenvalue with the smallest real part will be calculated. To calculate more eigenvalues use <code>howmany</code> keyword argument. For example, code below finds singlet and triplet energy of 2-site antiferromagnetic spin 1/2 Heisenberg chain (periodic) for spin coupling J = 1.</p><pre><code class="language-julia">system = Main.tJmodel1D.System(J = 1.0, size = 2, electrons = 2, spinsUp = 1)
system, basis, model, factorization = Main.tJmodel1D.run(system, howmany = 13)
                            ### we pretend we don&#39;t know it should be 2 ---^
eigenvalues, eigenvectors, convergenceInfo = factorization
real.(eigenvalues)</code></pre><pre class="documenter-example-output">2-element Vector{Float64}:
 -2.0
  0.0</pre><div class="admonition is-category-warn"><header class="admonition-header">Convergence</header><div class="admonition-body"><p>To make sure that there are no poorly converged values, it is always good to check <code>convergenceInfo</code>.</p><pre><code class="language-Julia">println(convergenceInfo)</code></pre><p>Norms of residuals close to zero indicate well converged values. </p></div></div><p>There should be no problems with convergence if you calculate just few eigenvalues. But in case you cannot converge desired number of eigenvalues, you may need to increase dimension of Krylov subspace. You can achieve this by setting keyword argument <code>kryldim</code> to value higher than 30 (which is default value). You can also set value smaller than 30 to save memory e.g. when looking for the lowest eigenvalue (and eigenvector) of a large system. Remember that <code>kryldim</code> cannot be smaller than <code>howmany</code>.</p><pre><code class="language-Julia">system, basis, model, factorization = Main.tJmodel1D.run(system, howmany = 40, kryldim = 100)</code></pre><h4 id="Skipping-diagonalization"><a class="docs-heading-anchor" href="#Skipping-diagonalization">Skipping diagonalization</a><a id="Skipping-diagonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Skipping-diagonalization" title="Permalink"></a></h4><p>If you just need Hamiltonian matrix and its basis tell the <a href="../documentation/#Main.tJmodel1D.run"><code>run</code></a> function to skip the factorization procedure by setting keyword argument <code>eigsolve = false</code>. In such case <code>factorization</code> will receive <code>missing</code> value from <a href="../documentation/#Main.tJmodel1D.run"><code>run</code></a>.</p><pre><code class="language-Julia">system, basis, model, factorization = Main.tJmodel1D.run(system, eigsolve = false)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Use dummy variables if you don&#39;t need some of returned objects.</p><pre><code class="language-Julia">_, _, _, factorization = Main.tJmodel1D.run(system)
system, basis, model, _ = Main.tJmodel1D.run(system, eigsolve = false)</code></pre></div></div><h3 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h3><p>Operators are defined in module <code>Operators</code>. You can use any of the predefined operators listed below.</p><h4 id="List-of-operators"><a class="docs-heading-anchor" href="#List-of-operators">List of operators</a><a id="List-of-operators-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-operators" title="Permalink"></a></h4><ul><li><span>$\hat{S}_{k}^{z}$</span>, <span>$\hat{S}_{r}^{z}$</span>, <span>$\hat{S}_{k}^{+}$</span>, <span>$\hat{S}_{r}^{+}$</span>, <span>$\hat{S}_{k}^{-}$</span>, <span>$\hat{S}_{r}^{-}$</span></li></ul><pre><code class="language-Julia">Sk_z(k::Int64; state::State, system::System)
Sr_z(r::Int64; state::State, system::System)
Sk_plus(k::Int64; state::State, system::System)
Sr_plus(r::Int64; state::State, system::System)
Sk_minus(k::Int64; state::State, system::System)
Sr_minus(r::Int64; state::State, system::System)</code></pre><ul><li><span>$\hat{\tilde{c}}_{k\uparrow}$</span>, <span>$\hat{\tilde{c}}_{r\uparrow}$</span>, <span>$\hat{\tilde{c}}_{k\downarrow}$</span>, <span>$\hat{\tilde{c}}_{r\downarrow}$</span></li></ul><pre><code class="language-Julia">ck_up(k::Int64; state::State, system::System)
cr_up(r::Int64; state::State, system::System)
ck_down(k::Int64; state::State, system::System)
cr_down(r::Int64; state::State, system::System)</code></pre><ul><li><span>$\hat{\tilde{c}}_{k\uparrow}^{\dag}$</span>, <span>$\hat{\tilde{c}}_{r\uparrow}^{\dag}$</span>, <span>$\hat{\tilde{c}}_{k\downarrow}^{\dag}$</span>, <span>$\hat{\tilde{c}}_{r\downarrow}^{\dag}$</span></li></ul><pre><code class="language-Julia">ck_up_dag(k::Int64; state::State, system::System)
cr_up_dag(r::Int64; state::State, system::System)
ck_down_dag(k::Int64; state::State, system::System)
cr_down_dag(r::Int64; state::State, system::System)</code></pre><p>If you&#39;re interested in calculations of correlation functions (Greens / Spectral function),  you can skip further subsections of <a href="#Operators">Operators</a> section and move straight to section <a href="#Correlation-functions">Correlation functions</a>.</p><h4 id="Applying-operators-to-wave-functions"><a class="docs-heading-anchor" href="#Applying-operators-to-wave-functions">Applying operators to wave-functions</a><a id="Applying-operators-to-wave-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-operators-to-wave-functions" title="Permalink"></a></h4><p>For given wave-function <span>$\psi$</span> from <code>system</code> subspace and operator <span>$\hat{O}_I$</span> (where <span>$I$</span> - ordered collection of indices) the result of <span>$\hat{O}_I \vert \psi \rangle$</span> can be calculated with <a href="../documentation/#Main.Operators.applyOperator"><code>applyOperator</code></a> function. For example, this is how to remove an electron with spin up and with momentum <span>$k = 0$</span>,</p><pre><code class="language-Julia">operator = Main.Operators.ck_up
result = Main.Operators.applyOperator(system, ψ, operator, 0)</code></pre><p>The first 3 arguments are always <code>system</code>, wave function <code>ψ</code> and <code>operator</code>. Further arguments are considered <code>operator</code> indices and will be passed to the <code>operator</code> function.  It is important to remember that the above <code>result</code> may in general overlap with multiple subspaces of the model. The <code>result</code> is a hash table with keys of type <a href="../documentation/#Main.tJmodel1D.System"><code>System</code></a> describing the resulting subspaces and values of type <code>Vector{ComplexF64}</code> representing corresponding subspace wave-functions.</p><pre><code class="language-julia">typeof(result)</code></pre><pre class="documenter-example-output">OrderedCollections.OrderedDict{Main.tJmodel1D.System, Vector{ComplexF64}}</pre><p>Once an operator is applied, one can for example calculate its expectation value on <code>ψ</code>.</p><pre><code class="language-Julia">E = if haskey(result, system)
    dot(ψ, result[system])
else
    0
end</code></pre><h4 id="Custom-Operators"><a class="docs-heading-anchor" href="#Custom-Operators">Custom Operators</a><a id="Custom-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Operators" title="Permalink"></a></h4><p>You can extend the original code base with your own operators. All you have to do is to put your operator function  in <code>custom.jl</code> file located in <code>.../tJMagnonHolon/src/modules/mods/</code> directory.  Every operator function follows the same design.</p><pre><code class="language-Julia">function operator_name(args...; state::State, system::System)::SystemSuperposition
    ...
end</code></pre><p>It takes any number of arguments <code>args...</code> which may for example represent operator indices. The magnon-holon basis <code>state</code> and corresponding <code>system</code> are passed as keyword arguments. For each basis state, the number of terms produced by the action of the operator is proportional to the <code>system.size</code> rather than <code>length(basis)</code>. For this reason, the output type is a sparse representation of a wave-function that may overlap with more than one subspace of the model.</p><pre><code class="language-Julia">SystemSuperposition = OrderedDict{System, Superposition}
Superposition = OrderedDict{State, ComplexF64} # state is paired with its coefficient</code></pre><p>If you plan to add a custom operator, it may be useful to have a look at the operators derivations in the <a href="../advanced/#Advanced">Advanced</a> section. </p><h3 id="Correlation-functions"><a class="docs-heading-anchor" href="#Correlation-functions">Correlation functions</a><a id="Correlation-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-functions" title="Permalink"></a></h3><p>You can calculate Greens/correlation functions for the <a href="#Hamiltonian">Hamiltonian</a> <span>$\hat{H}$</span> with <a href="../#tJMagnonHolon">tJMagnonHolon</a>. The following formula shows what kind of expression can be evaluated.</p><p class="math-container">\[\langle \psi \vert \hat{O}_{I}^{\dag} \frac{1}{\omega - \hat{H} + i\delta} \hat{O}_{I} \vert \psi \rangle\]</p><p>Above, <span>$\psi$</span> is any wave-function defined for a certain <code>system</code> subspace. Operator <span>$\hat{O}_{I}$</span> is any operator expressible in magnon-holon basis (i.e. with holon and magnon creation and annihilation operators). This operator can depend on any arbitrary ordered collection of indices <span>$I$</span>. For example <span>$I=(k,q)$</span> might represent momenta of two particles introduced to the system. </p><p>To generate a correlation function, define your resolution parameters,</p><ul><li>artificial broadening <span>$\delta$</span> of the spectral features,</li><li>set of <span>$\omega$</span> points at which spectral features should be calculated.</li></ul><p>For example:</p><pre><code class="language-Julia">δ = 0.02
ωRange = collect(-3:0.002:7)</code></pre><p>Smaller values of <span>$\delta$</span> will make features sharper and thinner. Accordingly, you need to set small enough step in <span>$\omega$</span> to resolve them. Otherwise, there will be too few points per peak to properly cover its shape. Step <span>$\delta / 10$</span> is usually small enough.</p><p>If the operator you use takes arguments (i.e. it has some indices), define a set of arguments to iterate over.  For example, if you use <span>$\hat{S}_{k}^{+}$</span>, define range of momenta <span>$k$</span> you want to evaluate.</p><pre><code class="language-Julia">kRange = collect(0:system.size)</code></pre><p>The actual values of operators arguments depend on their definition in the code. Here each <span>$k$</span> in the above set corresponds to momentum <code>2πk / system.size</code>.</p><p>We can now specify dimensions for <code>correlations</code> variable where we are going to store the results. We fill it with zeros to make sure there are no undefined values in it.</p><pre><code class="language-Julia">correlations = zeros(ComplexF64, length(ωRange), length(kRange))</code></pre><p>Now we can calculate the correlation function. For that we call function <a href="../documentation/#Main.Correlations.calculate"><code>calculate</code></a> from <code>Correlations</code> module and supply it with necessary arguments.</p><pre><code class="language-Julia">for k in kRange
    correlations[:, k + 1] = Main.Correlations.calculate(ωRange .+ E0, δ, system, ψ, operator, k)
end</code></pre><p>Above we shifted the set of energy points <code>ωRange</code> by the energy <code>E0</code> of the bare wave-function <code>ψ</code> for better alignment (the shift is optional). The <code>operator</code> with argument <code>k</code> is applied to <code>ψ</code> internally. Proper interpretation of <code>ψ</code> (which is just a vector of complex numbers) is allowed by <code>system</code> argument.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>On HPC and for large systems, instead of a single loop, consider separate runs for different operator arguments (or subsets of those). For example, you can run parallel calculations on separate nodes to obtain your results faster.</p></div></div><p>Apart from spectrum resolution settings, one more parameter has an influence on the quality of generated results. It is the maximum depth of recursion in the used algorithm for Greens function generation. You can change this parameter by setting <code>kryldim</code> keyword argument. The default value is <code>kryldim = 400</code>. In general, values between 200 and 500 should be optimal for most calculations. You can set smaller values to speed up calculations for fast lookup, but the result will lose some of its details. Use larger <code>kryldim &gt; 500</code> only if you need to zoom in on a small <span>$\omega$</span> window with relatively small broadening <span>$\delta$</span>. </p><pre><code class="language-Julia">Main.Correlations.calculate(ωRange, δ, system, ψ, operator, operatorArgs..., kryldim = 100)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../advanced/">Advanced »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 13 April 2025 17:41">Sunday 13 April 2025</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
