var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The purpose of this Guide is to provide a simple introduction to tJMagnonHolon features. It will allow you to start producing research relevant data right away.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Pages = [\n    \"guide.md\"\n]\nDepth = 3","category":"page"},{"location":"guide/#Introduction","page":"Guide","title":"Introduction","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"To start using tJMagnonHolon you need a distribution of Julia. You can download recent stable version from its official website julialang.org.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"tip: Tip\nCheck out the Manual section of the Julia documentation if you're not familiar with Julia programming language.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Following packages are required for tJMagnonHolon code to work.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"OrderedCollections\nLinearAlgebra\nSparseArrays\nKrylovKit\nDelimitedFiles\nDates\nJSON","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"To download them, open terminal and move to the following directory.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":".../tJMagnonHolon/src/","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In terminal type following command.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia setup.jl","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Required packages will be automatically downloaded and added to Julia (you need an internet connection). This step has to be done only once.  You can also add packages by yourself (e.g. if you already have some of them installed and don't wish to upgrade). ","category":"page"},{"location":"guide/#Tutorial","page":"Guide","title":"Tutorial","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Let us start with the basics.","category":"page"},{"location":"guide/#Running-the-code","page":"Guide","title":"Running the code","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Open terminal and move to the following directory.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":".../tJMagnonHolon/src/","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"in terminal type julia to start julia process, then in Julia REPL type include(\"run.jl\").\nalternatively type julia run.jl (to run without graphical interface).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"This will execute example_script.jl from .../tJMagnonHolon/src/scripts/ directory with all the tJMagnonHolon modules included. You can add more scripts to .../tJMagnonHolon/src/scripts/ (or to any location of your choice).  To execute one or more of those scripts include them in run.jl file.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"include(\"./scripts/my_script.jl\")","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Let us now learn about the features of the tJMagnonHolon.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"tip: Tip\nOpen example_script.jl on a side and compare how the discussed features are put together into a single script.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"note: [optional] Basic structure\nIt is convenient to define output type for results we want to collect. Let us call it Data.Data = OrderedDict{String, Union{Int64, Float64, Array{Float64}, Array{ComplexF64}}}You can write your script in the main scope of Julia but wrapping it in a function (or few functions) helps in organizing and reusing the code.function script()::Data\n    ...\nendAbove defined function script() is supposed to return output of type Data. You can also add some arguments to function script() or use different function name.","category":"page"},{"location":"guide/#System-definition","page":"Guide","title":"System definition","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"To perform any calculations we need to first define parameters of our system. All the system parameters are handled by System structure from tJmodel1D module. Let us use system for a corresponding variable name. There are multiple ways to define system but probably most readable is to use  System  function and provide a set of keyword arguments as in example below.  The order in which keyword arguments are listed is not important.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system = Main.tJmodel1D.System(\n    t           = 1.0,      # hole hopping\n    J           = 1.0,      # spin coupling\n    λ           = 1.0,      # magnon interaction\n    α           = 1.0,      # XXZ anisotropy scaling \n    size        = 16,       # number of lattice sites\n    electrons   = 16,       # number of electrons\n    spinsUp     = 8,        # number of spins up\n    momentum    = 0         # internal momentum subspace\n)","category":"page"},{"location":"guide/#Hamiltonian","page":"Guide","title":"Hamiltonian","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The first four parameters textcolororanget textcolororangeJ textcolororangelambda textcolororangealpha are parameters of the Hamiltonian hatH (in magnon-holon basis).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hatH = hatH_t + hatH_xx + hatH_z","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hatH_t = textcolororangetsum_langle ij rangle hath_i^dag hath_j left( hata_i + hata_j^dag right) + textrmHc","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hatH_xx = fractextcolororangealpha textcolororangeJ2 sum_langle ij rangle hath_i hath_i^dag left( hata_i hata_j + hata_i^dag hata_j^dag right) hath_j hath_j^dag","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hatH_z = fractextcolororangeJ2 sum_langle ij rangle hath_i hath_i^dag left(hata_i^dag hata_i + hata_j^dag hata_j - 2 textcolororangelambda hata_i^dag hata_i hata_j^dag hata_j - 1 right) hath_j hath_j^dag","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The last four parameters mathrmtextcolororangesize textcolororangeelectrons textcolororangespinsUp textcolororangemomentum are conserved by the Hamiltonian and point to a single subspace of the model (orthogonal to other subspaces). See section Advanced for detailed discussion.","category":"page"},{"location":"guide/#Other-ways-to-define-System","page":"Guide","title":"Other ways to define System","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Used in the above example values for system parameters are equal to the default values defined inside the tJmodel1D module.  To create a system with default values it is enough to call  System  function without arguments.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system = Main.tJmodel1D.System()","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can also provide any subset of keyword arguments. Not provided arguments will take default values.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system = Main.tJmodel1D.System(spinsUp = 0)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Additionally, if you wish to avoid to explicitly writing arguments names, you can use a constructor of System structure.  In this case the order of arguments matters, and it follows: (t, J, λ, α, size, electrons, spinsUp, momentum). ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system = Main.tJmodel1D.System(1.0, 1.0, 1.0, 1.0, 16, 16, 8, 0)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"System structure is immutable meaning that once you define it you cannot change values of its fields. But sometimes you may want to create a new instance of System  (let's call it newSystem) that has only one or few fields changed with respect to some previously defined system. In such case you can provide system as an argument to System function, see below.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"newSystem = Main.tJmodel1D.System(system, electrons = system.electrons - 1, spinsUp = system.spinsUp - 1)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Defined above newSystem has one electron less and one spin up less than system (e.g. one electron with spin up was removed). Values of other parameters are copied from system.","category":"page"},{"location":"guide/#Model-generation-and-factorization","page":"Guide","title":"Model generation and factorization","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Once system is known, you can call defined in tJmodel1D module function run to generate Hamiltonian matrix for subspace described by system and factorize it.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system, basis, model, factorization = Main.tJmodel1D.run(system)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"This function returns 3 objects and a tuple:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"System - parameters of the system subspace.\nBasis - basis of representative magnon-holon states for the system subspace.\nModel - generated sparse matrix of the Hamiltonian for the system subspace.\nfactorization = (eigenvalues, eigenvectors, convergenceInfo) - results of diagonalization procedure.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"note: Type and value note\nNote that eltype(eigenvalues) <: ComplexF64. Complex numbers may be returned if Model matrix has complex coefficients (even if imaginary parts are numerically zero). It is safe to assume that:eigenvalues::Vector{ComplexF64}\neigenvectors::Vector{Vector{ComplexF64}}Note that eigenvectors are determined up to a random (complex) phase that changes from run to run.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can easily access calculated eigenvalues and eigenvectors. For example, the first value and its corresponding vector:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"eigenvalues, eigenvectors, info = factorization\nψ = eigenvectors[1]\nE0 = real(eigenvalues[1])","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"note: Note\nEigenvalues are sorted with respect to real part from smallest to largest.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"By default, only 1 eigenvalue with the smallest real part will be calculated. To calculate more eigenvalues use howmany keyword argument. For example, code below finds singlet and triplet energy of 2-site antiferromagnetic spin 1/2 Heisenberg chain (periodic) for spin coupling J = 1.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system = Main.tJmodel1D.System(J = 1.0, size = 2, electrons = 2, spinsUp = 1)\nsystem, basis, model, factorization = Main.tJmodel1D.run(system, howmany = 13) \n                            ### we pretend we don't know it should be 2 ---^\neigenvalues, eigenvectors, convergenceInfo = factorization\nreal.(eigenvalues)\n[-2.0, 0.0] # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"warn: Convergence\nTo make sure that there are no poorly converged values, it is always good to check convergenceInfo.println(convergenceInfo)Norms of residuals close to zero indicate well converged values. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"There should be no problems with convergence if you calculate just few eigenvalues. But in case you cannot converge desired number of eigenvalues, you may need to increase dimension of Krylov subspace. You can achieve this by setting keyword argument kryldim to value higher than 30 (which is default value). You can also set value smaller than 30 to save memory e.g. when looking for the lowest eigenvalue (and eigenvector) of a large system. Remember that kryldim cannot be smaller than howmany.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system, basis, model, factorization = Main.tJmodel1D.run(system, howmany = 40, kryldim = 100)","category":"page"},{"location":"guide/#Skipping-diagonalization","page":"Guide","title":"Skipping diagonalization","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If you just need Hamiltonian matrix and its basis tell the run function to skip the factorization procedure by setting keyword argument eigsolve = false. In such case factorization will receive missing value from run.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"system, basis, model, factorization = Main.tJmodel1D.run(system, eigsolve = false)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"tip: Tip\nUse dummy variables if you don't need some of returned objects._, _, _, factorization = Main.tJmodel1D.run(system)\nsystem, basis, model, _ = Main.tJmodel1D.run(system, eigsolve = false)","category":"page"},{"location":"guide/#Operators","page":"Guide","title":"Operators","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Operators are defined in module Operators. You can use any of the predefined operators listed below.","category":"page"},{"location":"guide/#List-of-operators","page":"Guide","title":"List of operators","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"hatS_k^z, hatS_r^z, hatS_k^+, hatS_r^+, hatS_k^-, hatS_r^-","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Sk_z(k::Int64; state::State, system::System)\nSr_z(r::Int64; state::State, system::System)\nSk_plus(k::Int64; state::State, system::System)\nSr_plus(r::Int64; state::State, system::System)\nSk_minus(k::Int64; state::State, system::System)\nSr_minus(r::Int64; state::State, system::System)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hattildec_kuparrow, hattildec_ruparrow, hattildec_kdownarrow, hattildec_rdownarrow","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"ck_up(k::Int64; state::State, system::System)\ncr_up(r::Int64; state::State, system::System)\nck_down(k::Int64; state::State, system::System)\ncr_down(r::Int64; state::State, system::System)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"hattildec_kuparrow^dag, hattildec_ruparrow^dag, hattildec_kdownarrow^dag, hattildec_rdownarrow^dag","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"ck_up_dag(k::Int64; state::State, system::System)\ncr_up_dag(r::Int64; state::State, system::System)\nck_down_dag(k::Int64; state::State, system::System)\ncr_down_dag(r::Int64; state::State, system::System)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"If you're interested in calculations of correlation functions (Greens / Spectral function),  you can skip further subsections of Operators section and move straight to section Correlation functions.","category":"page"},{"location":"guide/#Applying-operators-to-wave-functions","page":"Guide","title":"Applying operators to wave-functions","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"For given wave-function psi from system subspace and operator hatO_I (where I - ordered collection of indices) the result of hatO_I vert psi rangle can be calculated with applyOperator function. For example, this is how to remove an electron with spin up and with momentum k = 0,","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"operator = Main.Operators.ck_up\nresult = Main.Operators.applyOperator(system, ψ, operator, 0)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The first 3 arguments are always system, wave function ψ and operator. Further arguments are considered operator indices and will be passed to the operator function.  It is important to remember that the above result may in general overlap with multiple subspaces of the model. The result is a hash table with keys of type System describing the resulting subspaces and values of type Vector{ComplexF64} representing corresponding subspace wave-functions.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"result = Main.Operators.SystemWaveFunction(Main.tJmodel1D.System() => [1.0im, 0.0]) # hide\ntypeof(result) ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Once an operator is applied, one can for example calculate its expectation value on ψ.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"E = if haskey(result, system)\n    dot(ψ, result[system])\nelse\n    0\nend","category":"page"},{"location":"guide/#Custom-Operators","page":"Guide","title":"Custom Operators","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can extend the original code base with your own operators. All you have to do is to put your operator function  in custom.jl file located in .../tJMagnonHolon/src/modules/mods/ directory.  Every operator function follows the same design.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"function operator_name(args...; state::State, system::System)::SystemSuperposition\n    ...\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"It takes any number of arguments args... which may for example represent operator indices. The magnon-holon basis state and corresponding system are passed as keyword arguments. For each basis state, the number of terms produced by the action of the operator is proportional to the system.size rather than length(basis). For this reason, the output type is a sparse representation of a wave-function that may overlap with more than one subspace of the model.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"SystemSuperposition = OrderedDict{System, Superposition}\nSuperposition = OrderedDict{State, ComplexF64} # state is paired with its coefficient","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"If you plan to add a custom operator, it may be useful to have a look at the operators derivations in the Advanced section. ","category":"page"},{"location":"guide/#Correlation-functions","page":"Guide","title":"Correlation functions","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can calculate Greens/correlation functions for the Hamiltonian hatH with tJMagnonHolon. The following formula shows what kind of expression can be evaluated.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"langle psi vert hatO_I^dag frac1omega - hatH + idelta hatO_I vert psi rangle","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Above, psi is any wave-function defined for a certain system subspace. Operator hatO_I is any operator expressible in magnon-holon basis (i.e. with holon and magnon creation and annihilation operators). This operator can depend on any arbitrary ordered collection of indices I. For example I=(kq) might represent momenta of two particles introduced to the system. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"To generate a correlation function, define your resolution parameters,","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"artificial broadening delta of the spectral features,\nset of omega points at which spectral features should be calculated.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"For example:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"δ = 0.02\nωRange = collect(-3:0.002:7)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Smaller values of delta will make features sharper and thinner. Accordingly, you need to set small enough step in omega to resolve them. Otherwise, there will be too few points per peak to properly cover its shape. Step delta  10 is usually small enough.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"If the operator you use takes arguments (i.e. it has some indices), define a set of arguments to iterate over.  For example, if you use hatS_k^+, define range of momenta k you want to evaluate.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"kRange = collect(0:system.size)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The actual values of operators arguments depend on their definition in the code. Here each k in the above set corresponds to momentum 2πk / system.size.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We can now specify dimensions for correlations variable where we are going to store the results. We fill it with zeros to make sure there are no undefined values in it.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"correlations = zeros(ComplexF64, length(ωRange), length(kRange))","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now we can calculate the correlation function. For that we call function calculate from Correlations module and supply it with necessary arguments.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"for k in kRange\n    correlations[:, k + 1] = Main.Correlations.calculate(ωRange .+ E0, δ, system, ψ, operator, k)\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Above we shifted the set of energy points ωRange by the energy E0 of the bare wave-function ψ for better alignment (the shift is optional). The operator with argument k is applied to ψ internally. Proper interpretation of ψ (which is just a vector of complex numbers) is allowed by system argument.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"tip: Tip\nOn HPC and for large systems, instead of a single loop, consider separate runs for different operator arguments (or subsets of those). For example, you can run parallel calculations on separate nodes to obtain your results faster.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Apart from spectrum resolution settings, one more parameter has an influence on the quality of generated results. It is the maximum depth of recursion in the used algorithm for Greens function generation. You can change this parameter by setting kryldim keyword argument. The default value is kryldim = 400. In general, values between 200 and 500 should be optimal for most calculations. You can set smaller values to speed up calculations for fast lookup, but the result will lose some of its details. Use larger kryldim > 500 only if you need to zoom in on a small omega window with relatively small broadening delta. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Main.Correlations.calculate(ωRange, δ, system, ψ, operator, operatorArgs..., kryldim = 100)","category":"page"},{"location":"advanced/#Advanced","page":"Advanced","title":"Advanced","text":"","category":"section"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"This section provides additional information about magnon-holon representation. We will cover here details of the transformation to magnon-holon basis, including:","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"sublattice-wise transformation of standard operators,\nstandard t-J Hamiltonian, its magnon-holon representation and generalization to t-J_xx-J_z(lambda) model,\nquantities preserved by the generalized Hamiltonian and commutation relation with translation operator,\ndefinition and numerical representation of momentum states and representative states in magnon-holon basis,\nexample derivations for operators action on magnon-holon representative basis states.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Let us start by denoting annihilation operators for magnon (hard-core boson) as hata and holon (spinless fermion) as hath.  The hard-core nature of the boson comes from s = 12 spin in the considered model. What we call the magnon-holon transformation is the procedure of rewriting operators in terms of hata and hath operators. Accordingly, we say that operator hatO expressed in terms of hata and hath is in magnon-holon representation (or in magnon-holon basis). Considering magnons as excitations around perfect antiferromagnetic spin background, below set of equations define the magnon-holon representation  of the standard operators in the tJMagnonHolon. We assume the system is one-dimensional with L = 2N sites, 0-based indexed, and N - positive integer.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"On sublattice A (sites with even indices 0 2 4  L - 2):","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\n\thattildec_iuparrow^dag = hatP_i hath_i quad hattildec_iuparrow = hath_i^dag hatP_i \n\thattildec_idownarrow^dag = hata_i^dag hatP_i hath_i quad hattildec_idownarrow = hath_i^dag hatP_i hata_i \n    hatS_i^+ = hath_i hath_i^dag hata_i quad hatS_i^z = left(frac12 - hata_i^dag hata_i right) hath_i hath_i^dag \n    hatS_i^- = hata_i^dag hath_i hath_i^dag quad hattilden_i = 1 - hath_i^dag hath_i = hath_i hath_i^dag\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"On sublattice B (sites with odd indices 1 2 5  L - 1):","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\n\thattildec_iuparrow^dag = hata_i^dag hatP_i hath_i quad hattildec_iuparrow = hath_i^dag hatP_i hata_i \n\thattildec_idownarrow^dag = hatP_i hath_i quad hattildec_idownarrow = hath_i^dag hatP_i \n    hatS_i^+ = hata_i^dag hath_i hath_i^dag quad hatS_i^z = left(hata_i^dag hata_i - frac12right) hath_i hath_i^dag \n    hatS_i^- = hath_i hath_i^dag hata_i quad hattilden_i = 1 - hath_i^dag hath_i = hath_i hath_i^dag\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"On both sublattices, hatP_i = 1 - hata_i^dag hata_i.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"With the above definition we can take the standard t-J Hamiltonian formulation,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH = -t sum_langle ij rangle sigma left( hattildec_isigma^dag hattildec_jsigma + mathrmHc right)\n        +  J sum_langle ij rangle left( hatS^x_i hatS^x_j + hatS^y_i hatS^y_j + hatS^z_i hatS^z_j - frac14 hattilden_i hattilden_j right)","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"and rewrite it to magnon-holon basis,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH = hatH_t + hatH_J","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH_t = t sum_langle ij rangle hatP_i left( hath_i^dag hath_j hata_i + hath_i^dag hath_j hata_j^dag right) hatP_j + textrmHc","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH_J = fracJ2 sum_langle ij rangle hath_i hath_i^dag left( hata_i hata_j + hata_i^dag hata_j^dag \n            + hata_i^dag hata_i + hata_j^dag hata_j - 2 hata_i^dag hata_i hata_j^dag hata_j - 1 right) hath_j hath_j^dag","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We extend the above model by introducing two additional parameters:","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"textcolororangealpha - anisotropy between quantization z-axis and perpendicular axes (XXZ anisotropy),\ntextcolororangelambda - scaling parameter for interactions between neighboring magnons (magnon-magnon interaction).","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH = hatH_t + hatH_xx + hatH_z","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH_t = t sum_langle ij rangle hatP_i left( hath_i^dag hath_j hata_i + hath_i^dag hath_j hata_j^dag right) hatP_j + textrmHc","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH_xx = fractextcolororangealpha J2 sum_langle ij rangle hath_i hath_i^dag left( hata_i hata_j + hata_i^dag hata_j^dag right) hath_j hath_j^dag","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH_z = fracJ2 sum_langle ij rangle hath_i hath_i^dag left(hata_i^dag hata_i + hata_j^dag hata_j - 2 textcolororangelambda hata_i^dag hata_i hata_j^dag hata_j - 1 right) hath_j hath_j^dag","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"For numerical diagonalization of an abstract model like the one above, it is important to determine its symmetries. Those symmetries generate quantities that are conserved by the model.  When writing the matrix of the model Hamiltonian in a basis, the basis may incorporate those symmetries, i.e. the basis states can be taken as eigen-states of the symmetry operators. Eigen-states that correspond to different eigenvalues of the symmetry operator are orthogonal. Thus, Hamiltonian written in such a basis will consist of orthogonal blocks that can be enumerated by the eigenvalues of the symmetry operators used for the basis construction. Each such block can be diagonalized separately, decreasing the amount of memory needed to store the Hamiltonian matrix and resulting eigen-states. But what constitutes a symmetry of our model? The word symmetry may be misleading in this case, since the symmetry does not have to reflect only geometrical properties. What we really look for when asking about the symmetries of the Hamiltonian, are operators that commute with the Hamiltonian,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH hatO = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"At the beginning, let us observe that the size L of the system is conserved by the model Hamiltonian.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Next, we can observe that our Hamiltonian does not change the number of electrons (holes). The corresponding operator is hatN = sum_i hattilden_i. One can check that,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH hatN = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"The eigenvalues of hatN are simply N_e in 0 1 2  L. This operator does not influence the system size either. Thus, subspace for given L can be split into further subspaces with different electron occupancy N_e.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"In similar way, once we set a system size L and number of electrons N_e, such subspace can be split into subspaces with different magnetization S^z_mathrmtot. The corresponding operator is hatS^z_mathrmtot = sum_i hatS^z_i. It indeed commutes with the Hamiltonian and does not break considered so far symmetries  (it commutes with their operators too),","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH hatS^z_mathrmtot = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatN hatS^z_mathrmtot = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"The standard Hamiltonian (and other previously mentioned operators) commute also with translation operator hatT. But it is not true for the generalized Hamiltonian. Generalized model commutes with hatT only for lambda = 1. This is related to distinguished sublattices in the transformation to magnon-holon basis. At the same time, the square of the translation operator, hatD = hatT^2 commutes with the generalized Hamiltonian for all values of lambda,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatH hatD = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We will call hatD an even translation operator. It of course commute with all the operators that hatT commutes with.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"All the above symmetries are incorporated in the tJMagnonHolon. But there is still a room for improvements. For example, parity symmetry is another symmetry that can be taken into account. It is important to remember that additional symmetries will make the basis in itself more complex. This can make the obtained results difficult to analyze or interpret. Thus stopping at the translation operator is optimal. Allowed system sizes are only few sites smaller than maximum for available computers. At the same time,  basis construction is still easy to understand.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Let us now construct the basis for our problem. Our requirements are that all the basis states are simultaneously eigen-states of all the mentioned symmetry operators: system size, number of electrons hatN, magnetization hatS^z_mathrmtot and even translation hatD. Let us start with representation that will automatically include the first three of them. We will use the following notation:","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"system size: L = 2N N in mathbbN,\nnumber of electrons: N_e in 0 1  L,\nnumber of spins up: n_uparrow in 0 1  N_e.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Notice that for given N_e the magnetization S^z_mathrmtot is uniquely defined by n_uparrow,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"    S^z_mathrmtot propto n_uparrow - n_downarrow = n_uparrow - (N_e - n_uparrow) = 2n_uparrow - N_e","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"where n_downarrow stands for number of spins down in the system. ","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We will use two 64-bit numbers to represent configuration of electrons and spins. This will set a limit of 64 to available system sizes, but apart from trivial cases we won't be able to calculate more than around 20-30 sites anyway.  Let us name the two numbers as charges and spins respectively. We will use L first bits of each of the number to represent presence (absence) of electrons and spins up. Our rules are simple. We connect bit values of 0 1 with occupancy.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"for charges:\n1 at i-th bit to electron at i-th site,\n0 at i-th bit to hole at i-th site,\nfor spins:\n1 at i-th bit to spin up at i-th site,\n0 at i-th bit to spin down i-th site.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Since bits are indexed from 0, we use the same indexing for sites. It may not be the most intuitive choice for physicists, but it is the most practical one (and natural for most programmers). It is also important to specify that only electron can carry a spin (holons are spinless fermions). To disambiguate the definition of the site occupied by a hole, we always set the bit of the spin variable to 0 if corresponding bit of charges variable is 0. Therefore, only 3 out of 4 combinations are meaningful for us (i-th bit of charges, i-th bit of spins) in(00) (10) (11).","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Before we follow with translation operator, let us transform the above representation to magnon-holon basis. We look at the details of the transformation to magnon-holon basis (operators defined at the beginning), and see that the transformation does not alter the electron/hole configuration.  We therefore use the above defined charges without changes. (Of course one can swap the meaning of 0 and 1 bit values, but using 0 for hole seems more intuitive). On the other hand, we have no spins in magnon-holon basis, but magnons instead. Let us define magnons - number that represents configuration of magnons in the system. On odd sites, spins up directly transform to magnons. If we chose 1s to represent presence of magnons then there's nothing to do there. On even sites on the other hand, spins down transform to magnons, so we have to transform all zeros to ones and all ones to zeros on even sites.  We call this last step a rotation of sublattice A (sublattice of even-indexed sites assuming 0-based indexing). There is of course a deeper meaning behind calling it a rotation, but it won't be important here.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"After the rotation of sublattice A is performed, we land at the following representation,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"for charges:\n1 at i-th bit to electron at i-th site,\n0 at i-th bit to hole at i-th site,\nfor magnons:\n1 at i-th bit to magnon at i-th site,\n0 at i-th bit to no magnon i-th site.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We disambiguate the hole representation in the same way as before (there cannot be both the hole and the magnon at the same site). The above corresponds to the State structure in the tJMagnonHolon code.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Let us now follow with introduction of momentum states - eigen-states of the even translation operator hatD. Let vert s L N_e n_uparrow rangle stand for a state with certain configuration of charges and magnons denoted by s  for a system with L = 2N N in mathbbN sites, N_e electrons, and n_uparrow spins up. Let us also shortly write vert s rangle when exact values of L N_e n_uparrow are not important. Notice that set of all s can be well-ordered since s is represented by a pair of integers. We define the magnon-holon momentum states in a standard way (we just use hatD instead of hatT),","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"vert s(k) rangle = frac1sqrtN_s sum_r = 0^N - 1 expleft(-frac2pi iNkrright) hatD^r vert s rangle","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"One can see that indeed vert s(k) rangle are eigen-states of hatD,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatD vert s(k) rangle = expleft(frac2pi iNkright) vert s(k) rangle","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"with eigenvalues expleft(frac2pi iNkright), where k in 0 1  N-1. This k variable enumerates the subspaces generated by even translation operator. When system variable of type System is created, k stands for system.momentum field. ","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Two more steps are required to form a basis out of the above defined momentum states. ","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"First: we need to make sure that they have unique representation (for linear independence of basis states).","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"For this we need to pick a representative state vert tildes rangle out of the set of even translations hatD^r vert s rangle of particular configuration s. Now the fact that set of all s can be well-ordered comes in handy. We define our ordering relation between s_1 and s_2. It will allow us to answer e.g. if s_1 is greater than s_2. For example, we can compare charges of the two configurations, and if charges are the same we compare magnons. With this we can pick the representative state vert tildes rangle such that tildes it the smallest out of all translations of particular configuration s.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Second: we need to make sure that state vert s rangle is compatible with momentum subspace k in 0  N-1.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"This is connected to normalizability of momentum states. Let us define periodicity of state vert s rangle, as the minimal number R_s  0 of even translations that transform vert s rangle onto itself,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"R_s = min  r in mathbbN setminus 0  hatD^r vert s rangle = vert s rangle ","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"The compatibility of vert s rangle with k requires that,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"kR_smod N = 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"If the above is fulfilled, the normalization factor N_s = fracN^2R_s. If the above is not fulfilled, then vert s(k) rangle equiv 0 is not normalizable.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Set of representative states compatible with k form a momentum basis for subspace with given L N_e S^z_mathrmtot k.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Equipped with the introduced notation, we are ready to derive some expressions for operators action on magnon-holon (momentum) basis states. To shorten the notation, from now on, we write exp(-ikr) instead of expleft(-frac2pi iNkrright). It should be clear to which momentum subspace we refer even if we use redefined k to enumerate it. Just remember that in the code momentum field of System is an integer from set 0  N-1.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We start with the simplest case of hatS^z_k operator,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatS^z_k = frac1sqrtL sum_r=0^L-1 exp(-ikr) hatS^z_r","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We evaluate its action on a magnon-holon momentum basis state vert tildes(p) rangle = vert tildes(p) L N_e n_uparrow rangle,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\nhatS^z_k vert tildes(p) rangle = frac1sqrtN_s sum_r=0^N-1 exp(-ipr) hatS^z_k hatD^r vert tildes rangle = frac1sqrtL N_s sum_r=0^N-1 sum_r=0^L-1 exp(-ipr - ikr) hatS^z_r hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) (-1)^r left( frac12 - hata^dag_r hata_r right) hath_r hath^dag_r hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) hatD^r (-1)^r left( frac12 - hata^dag_2r + r hata_2r + r right) hath_2r + r hath^dag_2r + r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp-i(p - 2k)r -ik(2r + r) hatD^r (-1)^r left( frac12 - hata^dag_2r + r hata_2r + r right) hath_2r + r hath^dag_2r + r vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p - 2k)r -ikR hatD^r (-1)^R - 2r left( frac12 - hata^dag_R hata_R right) hath_R hath^dag_R vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p - 2k)r -ikR hatD^r (-1)^R left( frac12 - hata^dag_R hata_R right) hath_R hath^dag_R vert tildes rangle \n= frac1sqrtL sum_R=0^L-1 exp(-ikR) alpha_R(tildes) vert tildes(p-2k) rangle\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"where (-1)^R left( frac12 - hata_R hata^dag_R right) hath^dag_R hath_R vert tildes rangle = alpha_R(tildes) vert tildes rangle. We intentionally provide all transformations step by step to showcase the derivation procedure. We use the definition of the momentum representation (Fourier transform) for both the operator and the state. We follow with the transformation of the operators to magnon-holon basis. Then we commute the even translation operator hatD with other operators. Next 3 lines are probably least transparent. We change the summation order, rendering the action of the operators (other than even translation operator) independent of the Fourier transform to momentum space. Finally, we evaluate the action of operators on the state vert tildes rangle, and we write the state back in the momentum space. It is immediately visible that alpha_R(tildes) evaluates to 0 when site R in state vert tildes rangle is occupied by a hole. When site R is not occupied by the hole, possible values of alpha_R(tildes) are given according to the table below,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"R in sublattice magnons at R in vert tildes rangle alpha_R(tildes)\nR in A 0 frac12\nR in B 0 -frac12\nR in A 1 -frac12\nR in B 1 frac12","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Using the result for hatS^z_k vert tildes(p) rangle, we easily obtain,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"hatS^z_r vert tildes(p) rangle = frac1sqrtL sum_q exp(iqr) hatS^z_q vert tildes(p) rangle = frac1L sum_qR exp-iq(R-r)alpha_R(tildes) vert tildes (p-2q) rangle","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"In practice, we assert the periodicity-momentum match between state vert tildes rangle and momentum p-2q by excluding from the above sum terms that do not fulfill periodicity-momentum relation.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Let us now work out the ladder operator hatS^+_k. Compared to the previous example, it will require few more steps, since it affects the number of spins up in the system.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\nhatS^+_k vert tildes(p) rangle = frac1sqrtN_s sum_r=0^N-1 exp(-ipr) hatS^+_k hatD^r vert tildes rangle = frac1sqrtL N_s sum_r=0^N-1 sum_r=0^L-1 exp(-ipr - ikr) hatS^+_r hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) (delta_r in A hata_r +delta_r in B hata^dag_r ) hath_r hath^dag_r hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) hatD^r (delta_r in A hata_2r + r + delta_r in B hata^dag_2r + r ) hath_2r + r hath^dag_2r + r vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r (delta_R-2r in A hata_R + delta_R-2r in B hata^dag_R ) hath_R hath^dag_R vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r left( frac1+(-1)^R2 hata_R + frac1-(-1)^R2 hata^dag_R right) hath_R hath^dag_R vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r frac12(hata_R + hata^dag_R) hath_R hath^dag_R vert tildes rangle \n+ frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r frac(-1)^R2(hata_R - hata^dag_R) hath_R hath^dag_R vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r alpha^+_R(tildes) vert s^+_R rangle + alpha^-_R(tildes) vert s^-_R rangle \n+ frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r beta^+_R(tildes) vert s^+_R rangle + beta^-_R(tildes) vert s^-_R rangle \n= frac1sqrtL N_s sum_R sqrtN_s^+_R exp(-ikR) alpha^+_R(tildes) + beta^+_R(tildes) vert s^+_R (p - 2k) rangle \n+ frac1sqrtL N_s sum_R sqrtN_s^-_R exp(-ikR) alpha^-_R(tildes) + beta^-_R(tildes) vert s^-_R (p - 2k) rangle \n= frac1sqrtL N_s sum_R sqrtN_s^+_R exp-ikR -i(p-2k)d_s^+_R alpha^+_R(tildes) + beta^+_R(tildes) vert tildes^+_R (p - 2k) rangle \n+ frac1sqrtL N_s sum_R sqrtN_s^-_R exp-ikR -i(p-2k)d_s^-_R alpha^-_R(tildes) + beta^-_R(tildes) vert tildes^-_R (p - 2k) rangle\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"with frac12(hata_R + hata^dag_R) hath_R hath^dag_R vert tildes rangle = alpha^+_R(tildes) vert s^+_R rangle + alpha^-_R(tildes) vert s^-_R rangle and frac(-1)^R2(hata_R - hata^dag_R) hath_R hath^dag_R vert tildes rangle = beta^+_R(tildes) vert s^+_R rangle + beta^-_R(tildes) vert s^-_R rangle, where vert s^pm_R rangle equiv vert s^pm_R L N_e n_uparrow pm 1 rangle comes from flipping a spin at site R in state vert tildes rangle.  The normalization factors sqrtN_s^pm_R appear since new states vert s^pm_R rangle may in general have periodicity different from vert tildes rangle.  These states may also not be representative states, so we need to find their representatives vert tildes^pm_R rangle and include proper phase shifts, as determined by the distance d_s^pm_R to the representative. Of course, beta^-_R(tildes) = -alpha^-_R(tildes) meaning that we can only increase the number of spins up (as expected from hatS^+_k). On the other hand, beta^+_R(tildes) = alpha^+_R(tildes) with alpha^+_R(tildes) equal to 0 when R is occupied by a hole, or otherwise it is given according to the table below.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"R in sublattice magnons at R in vert tildes rangle alpha^+_R(tildes)\nR in A 0 0\nR in B 0 frac12\nR in A 1 frac12\nR in B 1 0","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"From the above considerations, we see that the code for this operator shall first check if the value of alpha^+_R(tildes) is non-zero and only proceed if that's the case. Then the operators action on state vert tildes rangle simply alternates the R-th bit of magnons variable, which equates to XORing magnons with 2^R.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"As one can expect, derivation for hatS^-_k is analogical, with the same result form and following relations between coefficients,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"alpha^-_R(tildes) = beta^-_R(tildes) = frac12 - alpha^+_R(tildes) \nbeta^+_R(tildes) = -alpha^+_R(tildes)","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Also, hatS^pm_r can be obtained the same way as hatS^z_r.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Creation and annihilation operators for electrons follow the same scheme as spin ladder operators. For example,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\nhattildec_kdownarrow vert tildes(p) rangle = frac1sqrtN_s sum_r=0^N-1 exp(-ipr) hattildec_kdownarrow hatD^r vert tildes rangle = frac1sqrtL N_s sum_r=0^N-1 sum_r=0^L-1 exp(-ipr - ikr) hattildec_rdownarrow hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) (delta_r in A hath^dag_r hatP_r hata_r + delta_r in B hath^dag_r hatP_r) hatD^r vert tildes rangle \n= frac1sqrtL N_s sum_rr exp(-ipr -ikr) hatD^r (delta_r in A hath^dag_2r + r hatP_2r + r hata_2r + r + delta_r in B hath^dag_2r + r hatP_2r + r) vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p - 2k)r -ikR hatD^r (delta_R-2r in A hath^dag_R hatP_R hata_R + delta_R-2r in B hath^dag_R hatP_R) vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p - 2k)r -ikR hatD^r frac12 hath^dag_R hatP_R hata_R + 1 + (-1)^R (hata_R - 1) vert tildes rangle \n= frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r alpha^+_R(tildes) vert s^+_R rangle + alpha^-_R(tildes) vert s^-_R rangle \n+ frac1sqrtL N_s sum_rR exp-i(p-2k)r -ikR hatD^r beta^+_R(tildes) vert s^+_R rangle + beta^-_R(tildes) vert s^-_R rangle \n= frac1sqrtL N_s sum_R sqrtN_s^+_R exp-ikR -i(p-2k)d_s^+_R alpha^+_R(tildes) + beta^+_R(tildes) vert tildes^+_R (p - 2k) rangle \n+ frac1sqrtL N_s sum_R sqrtN_s^-_R exp-ikR -i(p-2k)d_s^-_R alpha^-_R(tildes) + beta^-_R(tildes) vert tildes^-_R (p - 2k) rangle\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"where the hole is added at site R in state vert s^pm_R rangle resulting in the increased(+)/decreased(-) magnetization with respect to vert tildes rangle.  The only non-zero contributions come from sites not occupied by the holes. Of course, even then the terms for decreased magnetization state must vanish, and indeed we have beta^-_R(tildes) = -alpha^-_R(tildes). In general, the coefficients in the above result follow the same relations as for hatS^+_k. On the other hand, for creation operator hattildec^dag_kdownarrow, only sites occupied by a hole give contribution. Then we are guaranteed that there are no magnons and in such case, beta^+_R(tildes) = -alpha^+_R(tildes) and simply beta^-_R(tildes) = alpha^-_R(tildes) = frac12.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"In the end, let us discuss operators with more than one index. Such operators may appear when calculating n-particle correlation functions. For example, let hatO_kq = hattildec_kuparrowhattildec_qdownarrow. Applying previous results, we obtain,","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"beginaligned\nhatO_kq vert tildes(p) rangle = hattildec_kuparrow sum_R sqrtfracN_s^+_RL N_s exp-iqR -i(p-2q)d_s^+_R alpha^+_R(tildes) + beta^+_R(tildes) vert tildes^+_R (p - 2q) rangle \n= sum_RR sqrtfracN_s^+-_RRL^2 N_s exp-iqR -i(p-2q)d_s^+_R exp-ikR -i(p-2q-2k)d_s^+-_RR times \ntimes alpha^+_R(tildes) + beta^+_R(tildes) alpha^-_R(tildes^+_R) + beta^-_R(tildes^+_R) vert tildes^+-_RR (p - 2q - 2k) rangle\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"It is important to mention that periodicity-momentum correspondence has to be checked for all the intermediate states, not only for the final state. This means that the sum over R only makes sense if state vert tildes^+_R rangle is compatible with momentum p-2q. Otherwise, one may introduce false non-zero contributions to the final result. Other than that, there are no surprises compared to previous examples. ","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"This summarizes our derivations. If you plan to introduce your own custom operators, read through Custom Operators subsection of the Guide.  You will learn there how the operators functions are designed in tJMagnonHolon. Then you may want to compare presented here derivations, with corresponding operators functions in the operators.jl file in .../tJMagnonHolon/src/modules/.","category":"page"},{"location":"#tJMagnonHolon","page":"Home","title":"tJMagnonHolon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"t-J model in magnon-holon basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A set of modules for t-J model (related) Hamiltonian diagonalization and various correlation functions generation.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generate sparse matrix of t-J model Hamiltonian in magnon-holon basis.\nGenerate full (small systems) or partial (large systems) set of eigenvalues and related eigenvectors of t-J model.\nCalculate operators action on wave functions in magnon-holon basis.\nCalculate correlation functions for the t-J model.\nSave data to JSON files and use them as data sets in Mathematica, R, Python, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Guide provides a tutorial explaining how to use above features. You will find there practical examples on how to run your calculations or how to extend the existing code base with your own operators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the Advanced section you can find technical discussion of the mathematics behind various features of the code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Documentation for the raw list of documented modules and features.","category":"page"},{"location":"#Guide-Outline","page":"Home","title":"Guide Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"guide.md\"\n]","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"This page contains a list of implemented types, methods, and functions.  All descriptions in the following sections are raw docstrings extracted from corresponding modules.  Sections are organized in order possible to read from top to bottom.  Each section ends with an alphabetical index organized by feature type in order: Type, Method, Function.","category":"page"},{"location":"documentation/#Module-tJmodel1D","page":"Documentation","title":"Module tJmodel1D","text":"","category":"section"},{"location":"documentation/#Features","page":"Documentation","title":"Features","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.System","category":"page"},{"location":"documentation/#Main.tJmodel1D.System","page":"Documentation","title":"Main.tJmodel1D.System","text":"struct System immutable structure for system input parameters:\n\nFields\n\nt::Float64: value of the hopping constant t.\nJ::Float64: value of the coupling constant J. For ferromagnet J < 0, for antiferromagnet J > 0.\nλ::FLoat64: parameter for scaling magnon-magnon interactions. For the pure t-J model λ = 1.0.\nα::Float64: parameter for scaling XXZ anisotropy. For t-J model α = 1.0, for t-Jz model α = 0.0.\nsize::Int64: number of lattice sites.\nelectrons::Int64: number of electrons (must be in range 0:System.size - Mott insulator constraint enforced).\nspinsUp::Int64: index in range 0:electrons indicating the number of spins up.\nmomentum::Int64: index of internal momentum sector in range 0:(System.size / 2 - 1). Index momentum corresponds to momentum k = 2π * momentum / (System.size / 2).\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.System(::Main.tJmodel1D.System)","category":"page"},{"location":"documentation/#Main.tJmodel1D.System-Tuple{Main.tJmodel1D.System}","page":"Documentation","title":"Main.tJmodel1D.System","text":"System(system::System = System(DEFAULT_ARGS...) [; t = system.t, J = system.J, ...,  momentum = system.momentum]) -> System\n\nCreate a new instance of System using system::System as a template with fields updated according to the given kwargs. Uses a default template if no template system::System is provided.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.checkSystem","category":"page"},{"location":"documentation/#Main.tJmodel1D.checkSystem","page":"Documentation","title":"Main.tJmodel1D.checkSystem","text":"Check if system::System describes a valid system. Throw error if any input parameter is invalid, otherwise return nothing.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.State","category":"page"},{"location":"documentation/#Main.tJmodel1D.State","page":"Documentation","title":"Main.tJmodel1D.State","text":"mutable struct State mutable structure for storing the configuration of electrons and magnons in magnon-holon basis using binary representation\n\nFields\n\ncharges::Int64: bit value 0 → hole,      1 → electron\nmagnons::Int64: bit value 0 → no magnon, 1 → magnon\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"hash","category":"page"},{"location":"documentation/#Base.hash","page":"Documentation","title":"Base.hash","text":"Hashing function for magnon-holon basis states.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"isequal","category":"page"},{"location":"documentation/#Base.isequal","page":"Documentation","title":"Base.isequal","text":"Compare magnon-holon basis states. Return true if s1::State and s2::State represent the same state, otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.getStateInfo","category":"page"},{"location":"documentation/#Main.tJmodel1D.getStateInfo","page":"Documentation","title":"Main.tJmodel1D.getStateInfo","text":"getStateInfo(state::State, system::System) -> Tuple{Bool, State, Int64, Int64}\n\nReturn (hasMomentum, representative, periodicity, distance) where\n\nhasMomentum::Bool: true if state matches momentum of system, and false otherwise\nrepresentative::State: representative state corresponding to state\nperiodicity::Int64: minimal R such that state shifted 2R times with translation operator returns back to state\ndistance::Int64: distance between state and representative state in number of even translations\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.isGreater","category":"page"},{"location":"documentation/#Main.tJmodel1D.isGreater","page":"Documentation","title":"Main.tJmodel1D.isGreater","text":"isGreater(a::State, b::State) -> Bool\n\nOrdering function for basis states in magnon-holon representation. Returns true if a > b, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.bitmov","category":"page"},{"location":"documentation/#Main.tJmodel1D.bitmov","page":"Documentation","title":"Main.tJmodel1D.bitmov","text":"bitmov(s::Int, l::Int, f::Bool = false; hb::Int = 1 << (l - 1), hv::Int = (1 << l) - 1) -> Int\n\nArithmetic bit shift for calculating bit translations with periodic boundary conditions.\n\nArguments\n\ns::Int - value which binary representation will be shifted\nl::Int - size of the cycle (total number of bits in the cycle)\nf::Bool - true -> move forward (~mult by 2); false -> backward (~div by 2); ~mult and ~div mean multiplication and division with preservance of periodic boundary conditions within cycle size l\nhb::Int [optional] - highest bit (for speed up put the value of 2^(l-1))\nhv::Int [optional] - highest value (for speed put (2^l)-1)\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.Basis","category":"page"},{"location":"documentation/#Main.tJmodel1D.Basis","page":"Documentation","title":"Main.tJmodel1D.Basis","text":"Basis = OrderedDict{State, Int64}\n\nBasis is stored as a hash table with Robin Hood hashing algorithm. Key corresponds to state of the system and value contains position of that state in basis.\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.makeBasis","category":"page"},{"location":"documentation/#Main.tJmodel1D.makeBasis","page":"Documentation","title":"Main.tJmodel1D.makeBasis","text":"makeBasis(system::System) -> Basis\n\nReturn Basis = OrderedDict{State, Int64} hash table representing basis for given System::system parameters.  Each index in Basis corresponds to State, and each value in Basis corresponds to position in the basis stored as Int64.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.sublatticeRotation","category":"page"},{"location":"documentation/#Main.tJmodel1D.sublatticeRotation","page":"Documentation","title":"Main.tJmodel1D.sublatticeRotation","text":"sublatticeRotation(charges::Int64, spins::Int64, mask::Int64) -> Int64\n\nPerform rotation of spins according to mask and return new spins configuration. Sites occupied by holes, according to charges parameter,  are not affected.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.LinearCombination","category":"page"},{"location":"documentation/#Main.tJmodel1D.LinearCombination","page":"Documentation","title":"Main.tJmodel1D.LinearCombination","text":"mutable struct LinearCombination: structure for storing result of Hamiltonian action on states from basis::Basis\n\nFields\n\nstate::State: system configurations in binary representation written as decimal number\ncoefficient::Vector{Complex{Float64}}: coeffcient multiplying state in the linear combination\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.hamiltonian","category":"page"},{"location":"documentation/#Main.tJmodel1D.hamiltonian","page":"Documentation","title":"Main.tJmodel1D.hamiltonian","text":"hamiltonian(state::State, basis::Basis, system::System) -> LinearCombination\n\nApply Hamiltonian to state written in Sz momentum basis obtained for input system parameters. Returns LinearCombination representing resulting states with their coefficients.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.Model","category":"page"},{"location":"documentation/#Main.tJmodel1D.Model","page":"Documentation","title":"Main.tJmodel1D.Model","text":"Model = SparseMatrixCSC{Complex{Float64},Int64}\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.makeModel","category":"page"},{"location":"documentation/#Main.tJmodel1D.makeModel","page":"Documentation","title":"Main.tJmodel1D.makeModel","text":"makeModel(basis::Basis, system::System) -> Model\n\nCalculate sparse matrix of the model::Model Hamiltonian, where Model = SparseMatrixCSC{Complex{Float64},Int64}.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.factorize","category":"page"},{"location":"documentation/#Main.tJmodel1D.factorize","page":"Documentation","title":"Main.tJmodel1D.factorize","text":"factorize(model::Model [; howmany = 1, which = :SR, kryldim = 30])\n\nCompute eigenvalues (by default with smallest real part) and their corresponding eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"note: Algorithm details\nFor more details about factorization procedure see documentation of  eigsolve function from KrylovKit.jl package.","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.tJmodel1D.run","category":"page"},{"location":"documentation/#Main.tJmodel1D.run","page":"Documentation","title":"Main.tJmodel1D.run","text":"run(input::Union{Missing, System} = missing; eigsolve = true, howmany = 1, kryldim = 30)\n\nRun model diagonalization procedure. If no input provided, construct input using default arguments. Return (system::System, basis::Basis, model::Model, factorization) where factorization is nothing if eigsolve == false. If eigsolve == true then factorization = (eigenvalues, eigenvectors, convergenceInfo). Algorithm tries to converge at least howmany eigenvalues.  Always print convergenceInfo to check accuracy since there is no warning if eigenvalues are poorly converged. Keyword kryldim allows to specify the dimension of Krylov subspace for diagonalization algorithm (implicitely restarted Lanczos iteration).\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]\nModules = [Main.tJmodel1D]","category":"page"},{"location":"documentation/#Module-Operators","page":"Documentation","title":"Module Operators","text":"","category":"section"},{"location":"documentation/#Features-2","page":"Documentation","title":"Features","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Operators.Superposition","category":"page"},{"location":"documentation/#Main.Operators.Superposition","page":"Documentation","title":"Main.Operators.Superposition","text":"Superposition = OrderedDict{State, Complex{Float64}}\n\nCompact representation of a wave function for single subspace. Alternative to sparse vector.\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Operators.SystemSuperposition","category":"page"},{"location":"documentation/#Main.Operators.SystemSuperposition","page":"Documentation","title":"Main.Operators.SystemSuperposition","text":"SystemSuperposition = OrderedDict{System, Superposition}\n\nCompact representation of a wave function overlaping with many subspaces of the model. \n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Operators.SystemWaveFunction","category":"page"},{"location":"documentation/#Main.Operators.SystemWaveFunction","page":"Documentation","title":"Main.Operators.SystemWaveFunction","text":"SystemWaveFunction = OrderedDict{System, Vector{Complex{Float64}}}\n\nRepresents a wave function vector that overlaps with many subspaces of the model.\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Operators.applyOperator","category":"page"},{"location":"documentation/#Main.Operators.applyOperator","page":"Documentation","title":"Main.Operators.applyOperator","text":"applyOperator(system::System, waveFunction::Vector{Complex{Float64}}, operator, args...) -> SystemWaveFunction\n\nApply operator with arguments args... to waveFunction of system subspace. In general, operator action on arbitrary wave function of a single subspace will overlap with many subspaces of the whole system. Return hash table SystemWaveFunction representing overlaping subspaces and corresponding resulting subspace wave functions.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Index-2","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]\nModules = [Main.Operators]","category":"page"},{"location":"documentation/#Module-Correlations","page":"Documentation","title":"Module Correlations","text":"","category":"section"},{"location":"documentation/#Features-3","page":"Documentation","title":"Features","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Correlations.Krylov","category":"page"},{"location":"documentation/#Main.Correlations.Krylov","page":"Documentation","title":"Main.Correlations.Krylov","text":"Immutable structure for passing parameters to Krylov subspace methods.\n\n\n\n\n\n","category":"type"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Correlations.calculateLanczos","category":"page"},{"location":"documentation/#Main.Correlations.calculateLanczos","page":"Documentation","title":"Main.Correlations.calculateLanczos","text":"calculateLanczos(initialState::Vector{Complex{Float64}}, model::Model, krylov::Krylov)\n\nCalculate tridiagonal form of hermitian model for given krylov parameters of Krylov subspace starting from initialState. Return compact form (diagonal, offDiagonal, size) of symmetric tridiagonal matrix as two vectors of diagonal and offDiagonal terms with sizes size and size-1 respectively. \n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Correlations.greensFunction","category":"page"},{"location":"documentation/#Main.Correlations.greensFunction","page":"Documentation","title":"Main.Correlations.greensFunction","text":"greensFunction(ω::Complex{Float64}, initialState, diagonal, offDiagonal, size) -> Complex{Float64}\n\nCalculate the value of Greens function for given ω point. Internally evaluates a continued fraction of depth size based on results diagonal and offDiagonal of Lanczos tridiagonalization procedure. The result is re-scaled by the norm of initialState.\n\n\n\n\n\ngreensFunction(ωRange::Vector{Float64}, iDelta::Complex{Float64}, initialState::Vector{Complex{Float64}}, diagonal::Vector{Float64}, offDiagonal::Vector{Float64}, size::Int64) -> Vector{Complex{Float64}}\n\nCalculate Greens function over range of points ωRange applying data broadening iDelta.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Correlations.run","category":"page"},{"location":"documentation/#Main.Correlations.run","page":"Documentation","title":"Main.Correlations.run","text":"run(ωRange::Vector{Float64}, iDelta::Complex{Float64}, initialState::Vector{Complex{Float64}}, model::Model, krylovDimension::Int64 = 400)\n\nRun Lanczos tridiagonalization of a subspace model starting from initialState including up to krylovDimension dimensions. Return Greens function calculated over range ωRange with data broadening iDelta.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Correlations.calculate","category":"page"},{"location":"documentation/#Main.Correlations.calculate","page":"Documentation","title":"Main.Correlations.calculate","text":"calculate(ωRange, δ, system, ψ, operator, args...; kryldim = 400) -> Vector{ComplexF64}\n\nApply operator with arguments args... to system wave function ψ. Then calculate correlation function over ωRange with artificial broadening δ using Lanczos tridiagonalization with initial state Ô | ψ >. Return Vector{ComplexF64} of size length(ωRange) with calculated values of the correlation function. A keyword argument kryldim defines maximum dimension of Krylov subspace for Lanczoas tridiagonalization algorithm. Typically values of kryldim ∈ [100, 1000] give best performance. Small values of kryldim speed up the calculation process but reduce the quality of results. It is not advised to set Krylov dimension too high - performance eventually drops due to orthogonality loss.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Index-3","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]\nModules = [Main.Correlations]","category":"page"},{"location":"documentation/#Module-Utils","page":"Documentation","title":"Module Utils","text":"","category":"section"},{"location":"documentation/#Features-4","page":"Documentation","title":"Features","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Main.Utils.saveData","category":"page"},{"location":"documentation/#Main.Utils.saveData","page":"Documentation","title":"Main.Utils.saveData","text":"saveData(data [; path::String = \"./data/\", name::Union{Missing, String} = missing])\n\nSave data to JSON file name.json in path directory. If name not provided, current time in format \"Y-mm-dd_HH:MM:SS.s\" is used as file name. Requires typeof(data) <: AbstractDict.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#Index-4","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\"documentation.md\"]\nModules = [Main.Utils]","category":"page"}]
}
